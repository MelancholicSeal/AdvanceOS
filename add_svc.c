/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "add.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <semaphore.h>
#include <sys/types.h>
#include <sys/select.h>
#include <sys/wait.h>

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

struct msg {
   int id;
   int val;
};
static void
add_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		numbers add_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case add:
		_xdr_argument = (xdrproc_t) xdr_numbers;
		_xdr_result = (xdrproc_t) xdr_int;
		local = (char *(*)(char *, struct svc_req *)) add_1_svc;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

int tmp = 0; 
int N;
int* pid;
int** fd;
int** cfd;


void kill_child(int sig){
    printf("\nCaught signal %d (SIGINT). Exiting gracefully...\n", sig);
    
    for(int i=1; i<=N; i++){
        if(kill(pid[i],SIGINT)==-1){
            printf("%d\n", pid[i]);
        }
    }
    for(int i=1; i<=N; i++){
       
        waitpid(pid[i], NULL,0);
    }

    // close pipes
    for (int i = 1; i <= N; i++) {
        close(fd[i][1]);
        close(cfd[i][0]);
    }
    // Free the allocated memory before exiting the program
    for (int i = 0; i <= N; i++) {
        free(fd[i]);  // Free each row
    }
    free(fd);
    for (int i = 0; i <= N; i++) {
        free(cfd[i]);  // Free each row
    }    
    free(cfd);
    free(pid);
    exit(0);
}
void term_child(int sig){
    printf("\nCaught signal %d (SIGINT). Exiting gracefully...\n", sig);
    // close pipes
    close(fd[tmp][0]);
    close(cfd[tmp][1]);

    // Free the allocated memory before exiting the program
    for (int i = 0; i <= N; i++) {
        free(fd[i]); 
    }
    free(fd);
    for (int i = 0; i <= N; i++) {
        free(cfd[i]);  
    }
    free(cfd);
    free(pid);
    exit(0);
}








int
main (int argc, char **argv)
{
	register SVCXPRT *transp;

	pmap_unset (ADD_PROG, ADD_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, ADD_PROG, ADD_VERS, add_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (ADD_PROG, ADD_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, ADD_PROG, ADD_VERS, add_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (ADD_PROG, ADD_VERS, tcp).");
		exit(1);
	}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	N = 3;

    pid = malloc((N+1)*sizeof(int));    
    int a = 1;
    

    // Initialize pipes
    fd = (int **)malloc((N + 1) * sizeof(int *));//father writes
    cfd = (int **)malloc((N + 1) * sizeof(int *));//child writes
    for (int i = 1; i <= N; i++) {
        fd[i] = (int *)malloc(2 * sizeof(int));
        cfd[i] = (int *)malloc(2 * sizeof(int));
    }
    for (int i = 1; i <= N; i++) {
        if (pipe(fd[i]) < 0) return 1;
        if(pipe(cfd[i]) < 0) return 1;
    }

    FILE *out;
    for (int i = 1; i <=N; i++) {
        if (a > 0) {
            tmp++;
            a = fork();
            pid[i]=a;
        }
    }

    // close unnecessary pipes for parent
    if (a > 0) {
        for (int i = 1; i <= N; i++) {
            close(fd[i][0]);
            close(cfd[i][1]);
        }
        //signal(SIGINT, kill_child);

        struct sigaction sa;
        sa.sa_handler = kill_child; 
        sa.sa_flags = 0; 
        sigemptyset(&sa.sa_mask);
        sigaction(SIGINT, &sa, NULL);
    }
    // close unnecessary pipes for child
    else {
        for (int i = 1; i <= N; i++) {
            close(fd[i][1]);
            close(cfd[i][0]);
            if (tmp != i) close(fd[i][0]);
            if(tmp!=i) close(fd[i][1]);
        }

        struct sigaction sa;
        sa.sa_handler = term_child;  
        sa.sa_flags = 0; 
        sigemptyset(&sa.sa_mask);
        sigaction(SIGINT, &sa, NULL);
    }
///////////////////////////////////////////////////////
	if(a>0){
		fd_set readfds;   // File descriptor set to be used with select()
		struct timeval timeout;

		int av[N+1];
        for (int i = 0; i <=N; i++) {
            av[i] = 1;  // mark all workers as available initially
        }

		while (1) {
			// Get the file descriptor set that need attention
			FD_ZERO(&readfds);
			readfds = svc_fdset;

			// Use select to block until we have something to read
			timeout.tv_sec = 0;  // Set a timeout (optional)
			timeout.tv_usec = 5000;
			int nready = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);

			if (nready > 0) {
				for (int i = 1; i <= N; i++) {
					if (av[i]) {
						struct msg mes={i,1}; 
						ssize_t write_bytes = write(fd[i][1], &mes, sizeof(mes));
						if (write_bytes <= 0) {
							printf("Parent: Failed to write to worker %d\n", i);
						}
						av[i] = 0;  // mark worker as busy
						break;
					}
				}
				
			}

			// Check for completion messages from workers
            fd_set rfds;
            FD_ZERO(&rfds);
            for (int i = 1; i <= N; i++) {
                FD_SET(cfd[i][0], &rfds);
            }

            struct timeval tv = {0, 5000};  
            int retval = select(FD_SETSIZE + 1, &rfds, NULL, NULL, &tv);
            if (retval == -1) {
                return 3;
            }
            if (retval > 0) {
                // read message from worker
                for(int i=1; i<=N; i++){
                    if (FD_ISSET(cfd[i][0], &rfds)) {
                        struct msg mes;
                        ssize_t read_bytes = read(cfd[i][0], &mes, sizeof(mes));
                        if (read_bytes <= 0) {
                            printf("Parent: Failed to read from worker pipe\n");
                            continue;
                        }
                        // mark worker as available if task is complete
                        if (mes.val == 0) {
                            av[mes.id] = 1;
                        }
                    }
                }
            }
		}
	}
	else{
		
		while(1){
			struct msg mes;
            ssize_t read_bytes = read(fd[tmp][0], &mes, sizeof(mes));  // read task from parent
            if (read_bytes <= 0) {
                printf("Worker %d: Failed to read from pipe\n", tmp);
                continue;
            }  
			
			fd_set readfds = svc_fdset;
			struct timeval timeout;
			// Use select to block until we have something to read
			timeout.tv_sec = 0;  // Set a timeout (optional)
			timeout.tv_usec = 5000;
			int nready = select(FD_SETSIZE, &readfds, NULL, NULL, &timeout);
			svc_getreqset(&readfds);
			
            mes.val=0;
            ssize_t write_bytes = write(cfd[tmp][1], &mes, sizeof(mes));  // notify parent of completion
            if (write_bytes <= 0) {
                printf("Worker %d: Failed to write to pipe\n", tmp);
            }
		}
	}
	
}
